[
  {
    "id": "final-shot",
    "slug": "final-shot",
    "title": "Final Shot",
    "year": "N/A",
    "shortDescription": "48-hour rapid prototype featuring magical spells",
    "tags": [
      "UE5",
      "Blueprint",
      "Tech Art",
      "Solo"
    ],
    "platform": "PC",
    "engine": "Unreal Engine 5",
    "teamSize": "Solo",
    "role": "Solo",
    "language": "Blueprint",
    "duration": "48 hours",
    "description": "Final Shot is a solo Unreal Engine 5 mage arena shooter built in 48 hours for the Introduction to Game Scripting final at the University of Utah. It delivers the required two-level structure (practice range and showdown) and expands it with a full menu flow, a victory loop, resource-driven combat (health, stamina, mana), and a stylized presentation centered on spellcasting and readable combat feedback.",
    "challenges": "Final Shot was built for a tightly scoped class brief that defined the game loop, UI, and progression rules up front, and I chose to exceed that scope while finishing in 48 hours. The hard part was hitting every required behavior (level progression, health rules, UI counts, and enemy patterning) and still leaving time for polish, animation, and VFX without breaking the spec or flow. The assignment checklist was:\r\n\r\n- Build a player character that can shoot bullets.\r\n- Include two levels: a shooting range and a showdown.\r\n- In the range, hit five targets with a visible target count; clear all to advance.\r\n- In the showdown, fight an enemy that cycles three fixed locations and shoots at the player.\r\n- Both player and enemy use three-hit health rules; player death restarts the level and enemy death ends the game.\r\n- UI must show targets destroyed/remaining, player health, and enemy health when present.\r\n- Include a bullet actor with projectile movement, hit logic, and distinct fire/impact audio.\r\n- Use required blueprints and input mapping (shoot input with a one-second cooldown).",
    "process": "I implemented the core systems in Blueprint: a shoot input with cooldown, a bullet actor with projectile movement and hit logic, a target actor that increments a target counter, and an enemy AI that cycles fixed positions and fires at the player. The UI covers target counts, player/enemy health, and win/lose messaging. Beyond the base spec, I added a main menu with level selection, a charged fireball that scales size and damage over a three-second charge, and expanded the showdown into a four-mage fight with ice projectiles and a victory return to the main menu.",
    "custom1": "Level Design\r\n\r\nThe Target Range is a small forest practice area blocked out with the landscape tool and asset-bashed trees and stone surfaces. I built a target tool that moves targets along spline paths or lifts them on a wooden plank, and once 10 targets are destroyed a portal gate rises to load the Battle Arena. The Battle Arena is a Roman colosseum-inspired pit with a spectator ring, pillars, boulders, and four entrances where AI mages spawn. Both levels share a pickup-pad tool that periodically spawns mana crystals or health potions based on an exposed chance value.",
    "custom2": "Tech Art and Animation\r\n\r\nI retargeted Mixamo animations and blended the firing animation with idle/run so casting reads during movement. Timelines synchronize VFX and SFX with casting, release, and impact. Fireball and iceball effects are built in three stages (hand hold, projectile flight, impact) with layered emitters, and I created a custom cel shader using luminance thresholds to tune the stylized lighting.",
    "status": "N/A"
  },
  {
    "id": "ghost-ctrl",
    "slug": "ghost-ctrl",
    "title": "Ghost CTRL",
    "year": "N/A",
    "shortDescription": "Dystopian cyberpunk extraction shooter with playable demo",
    "tags": [
      "UE5",
      "Level Design",
      "Tech Art",
      "Solo"
    ],
    "platform": "PC",
    "engine": "Unreal Engine 5",
    "teamSize": "Solo",
    "role": "Solo",
    "language": "Blueprint",
    "duration": "6 weeks",
    "description": "Ghost CTRL is a solo Unreal Engine 5 prototype built as the final project for my Level Design course at the University of Utah (taught by Jennifer Egan), developed over six weeks and roughly 400 hours. It is a single‑player extraction shooter set in a compact modern city, where the player must locate a randomly spawned laptop, hold position to complete a 30‑second download, then navigate to a randomly spawned extraction point and survive the final countdown. The demo was scoped to satisfy strict course requirements while also serving as a recruitment‑ready pitch for my studio’s continuation project, Ghost Core.",
    "challenges": "Ghost CTRL was the final project for my Level Design course at the University of Utah, taught by Jennifer Egan, and the assignment came with a strict checklist. The requirements were:\r\n\r\n- Create a primary mechanic beyond the default Unreal templates, built by me.\r\n- Create a secondary, environment-based mechanic built by me.\r\n- Do not use premade plugins or asset packs.\r\n- Use flat colors only (no default Unreal textures or grids).\r\n- Include SFX and background audio.\r\n- Ensure player movement fits the level metrics.\r\n- Deliver a polished level that runs at least 4–5 minutes.\r\n- Avoid geometry/collision issues.\r\n- Use good, attractive lighting and clear visual language.\r\n- Provide a clear end goal and avoid the “floating in space” feel.\r\n- Submit a playable package and a video.\r\n\r\nI chose to exceed the course baseline by treating the project as a recruitment‑ready demo for my own studio (and the continuation project, Ghost Core), which raised the quality bar on systems, readability, and replayability. That scope had to fit into a six‑week schedule and roughly 400 hours of solo development time, which meant I had to prioritize systems that were both impressive and achievable, while also self‑teaching new areas like Unreal’s behavior tree + EQS and a pixel‑perfect ASCII UI pipeline without letting the level polish slip.",
    "process": "I structured the project around a single‑player extraction loop: explore the city, secure a randomly spawned laptop objective, complete a defend‑in‑place download timer, then locate a randomly spawned extraction point and survive the final countdown. The primary mechanic is gunplay, so I built two weapons from scratch (pistol and SMG) with custom ammo, reload, damage tuning, and knockback feedback, then wired their line‑trace hits into VFX. To make the loop playable and scalable beyond the course, I built a spawn manager system and designer‑facing spawner actors for enemies and loot, which let me control spawn rates and randomization while keeping the map replayable. Playtests exposed that the first pass was too punishing and unclear: players died often, struggled to locate the laptop objective, and felt like enemies were “sneaking up” on them. I iterated multiple times on difficulty by tuning enemy speed, health, and spawn rate, and I added visual behavior indicators to the enemies to communicate threat states and presence. The end result consistently ran longer than the 4–5 minute requirement, and the randomized objective and loot spawns created a new route and pacing on each run.",
    "custom1": "Level Design\r\n\r\nThe level is a compact, modern city inspired by Counter‑Strike layouts, built for readability and varied elevations rather than raw size. I designed a street grid with accessible first‑floor interiors, a sewer route, and a condensed rural edge to create vertical variation, alternate approaches, and overlapping sightlines without making the play space overwhelming. Because unique architecture is expensive in a six‑week solo build, I created a procedural building generator to populate the skyline and non‑playable zones; by constraining X, Y, and Z size ranges and randomizing window patterns, I could bake multiple building silhouettes quickly and use them as set dressing to avoid the unfinished “floating in space” feel. Objective placement was deliberate: laptop spawners encourage exploration of multiple zones, while download locations are chosen for defendability and sightline control, and extraction points are placed to make the final sprint tense without being unfair. Lighting and color were kept clean and purposeful to maintain a consistent visual language and guide the player toward goals and routes.",
    "custom2": "System and UI\r\n\r\nEnemies are hacked synthetic humans (“synths”) driven by a behavior tree and EQS. They have four readable states, each signaled by a spotlight color: red for active chase via sight, orange for investigating last‑seen position, yellow for sound‑based investigation (gunfire has distinct hearing ranges), and blue for passive roaming. EQS lets them search blind spots around the last‑seen area rather than beelining unrealistically, and the light system both communicates intent and prevents players from feeling blindsided. Combat includes locational damage multipliers (headshots at 2x, limb hits at 0.5x) and knockback so each weapon feels distinct and rewards precision. The objective system uses randomized laptop and extraction spawns, with a 30‑second “stay‑in‑zone” download timer that forces area defense, followed by a separate 30‑second extraction timer that allows free movement. The UI is built entirely with a CP437 monospaced ASCII typeface, which required careful pixel‑perfect setup to avoid artifacting. I used ASCII borders and bars for health and stamina, a Blueprint‑driven event log for loot, damage, and objective changes, and a four‑step objective tracker that communicates the loop clearly: Find Lost Data, Download Data, Head to Extraction, and Extract.",
    "status": "N/A"
  },
  {
    "id": "insomniac",
    "slug": "insomniac",
    "title": "Insomniac",
    "year": "N/A",
    "shortDescription": "N/A",
    "tags": [
      "UE5",
      "Level Design",
      "Solo"
    ],
    "platform": "PC",
    "engine": "Unreal Engine 5",
    "teamSize": "Solo",
    "role": "Solo",
    "language": "Blueprint",
    "duration": "6 weeks",
    "description": "Insomniac is a walking simulator set in a dystopian underground South Korean megastructure, featuring an abandoned apartment complex and subway system. The player navigates through a brutalist concrete world that stretches infinitely upward and downward into fog, collecting caffeine vitamins while exploring the grim remnants of a harsh work culture. The level emphasizes environmental storytelling through set dressing, lighting, and spatial design to communicate the oppressive nature of overwork and dependency.\r\nThis was the first project I developed during the Level Design course at the University of Utah (Jennifer Egan, Fall 2025). The assignment required visiting a real-world location in person, documenting it with photos and notes, and then creating a game level inspired by—but not directly copying—that space. I based my level on architecture and work culture observations from a South Korea visit during summer of the same year. Development ran for six weeks.",
    "challenges": "The assignment came with strict content and technical requirements:\r\n- Must use flat colors only; no default Unreal textures or grids.\r\n- No textured materials, including premade wood, stone, or leaves.\r\n- Must not use the landscape tool (unless discussed with instructor).\r\n- No high-poly or premade assets, including starter content.\r\n- Level must be polished with no geometry/collision issues and no areas of complete darkness.\r\n- Lighting pass required.\r\n- Around 2-5 minutes of gameplay (excessively short levels would lose points).\r\n- Must have functional collectibles.\r\n- Cannot contain excessive platforming or require additional mechanics (like guns).\r\n- Player cannot die, fall off edges, or have to restart.\r\n- Must submit both video walkthrough and playable packaged build.\r\n\r\nThe focus was on how a space feels to walk through and whether it's interesting to look at, not player mechanics. Beyond jumping minimally, walking should be the only required mechanic.\r\nMy initial design challenge was handling tall apartment buildings—the higher the player climbs, the farther they can see, which could break immersion or reveal unfinished areas. To solve this, I shifted the setting to be dystopian and brutalist, taking the apartments underground into a vertical megastructure that uses fog to obscure the infinite pit above and below. This constrained the view while reinforcing the oppressive, liminal atmosphere.",
    "process": "I started by planning the general theme and world structure in-engine, prototyping how the player would traverse the space and designing the three main sections: the outside megastructure (bridges and the infinite pit), the apartment complex interior, and the subway station. The project required collectibles to guide the player, so I designed caffeine vitamin bottles with rotating animation and emissive materials to make them easily identifiable from a distance, even in darker areas.\r\nThematically, I leaned into South Korean work culture—long hours, competitive job markets, unhealthy stress, and widespread smoking as a coping mechanism. I pushed this further into environmental storytelling by making the world feel post-apocalyptic: run-down interiors, disorganized set dressing, broken/flickering lights, and knocked-over furniture. The dark gray concrete palette reinforced the brutalist aesthetic, while the vibrant emissive vitamins created intentional contrast—they represent the dependency on stimulants just to survive daily life in this grim world.\r\nThe player must collect at least 10 vitamins before entering the train at the end. Upon finishing, the level resets the player back to spawn with all vitamins respawned, creating a looping dream-like experience that suggests hallucination from overconsumption of caffeine.",
    "custom1": "World Setting & Theme\r\n\r\nThe dystopian underground megastructure is designed to feel infinite, oppressive, and liminal. The outer apartment walls stretch infinitely upward and downward into dense fog, obscuring the true scale and reinforcing the sense of being trapped in a concrete purgatory. The lack of sunlight and the grayscale color scheme (with sparse color highlights like the vitamins and flickering lights) create a suffocating, lifeless mood.\r\n\r\nLong bridges connect different sections of the megastructure in non-structured, obscure placements, making the architecture feel dynamic and unstable. The broken bridge at the spawn area immediately teaches the player that not all paths are accessible, gently guiding navigation without explicit UI. Looking down from any bridge reveals the bottomless pit extending into darkness and fog, reinforcing scale and dread.\r\n\r\nInside the apartment complex and subway, environmental storytelling takes over. Stores are almost entirely empty, with shelves knocked over, mannequins tilted against walls or lying on the floor, and clothing racks disoriented. Broken and flickering lights add tension and visual interest while communicating neglect and decay. The women's bathroom is blocked off with traffic cones, implying it's out of order or unsafe. These small details—combined with the concrete brutalist construction—sell the idea of a society that has collapsed under the weight of overwork and unhealthy dependency on stimulants.\r\n\r\nThe caffeine vitamin bottles serve as both gameplay collectibles and thematic anchors. Their bright emissive glow contrasts sharply with the dark, lifeless world, symbolizing the only \"color\" or \"life\" left in this dystopia—artificial energy to keep people moving through an unbearable routine.",
    "custom2": "Level Design\r\n\r\nThe level is split into three main sections with deliberate pacing and navigation flow:\r\n\r\n1. Outside Megastructure (Spawn & Bridges):  \r\nThe player spawns on the outer wall of the apartment complex at a three-way bridge intersection. One connection is completely broken, blocking that path and subtly guiding the player toward the correct route. The other connection leads across a long bridge to the center apartment building. Looking down reveals the infinite pit with fog obscuring the bottom, immediately establishing scale and tone. Looking up shows more apartment floors and bridges stretching into darkness and fog above. This opening moment sets the mood and teaches the player that exploration will be vertical and constrained by the megastructure's layout.\r\n\r\n2. Center Apartment Complex (Interior & Staircase):  \r\nUpon entering the center building via the bridge, the player finds a hallway with closed-off rooms except for one accessible room. At the center of the building is a staircase that allows vertical traversal. The upper staircase leads into darkness with an invisible barrier, gently signaling it's not the correct path. The player can explore 3-4 accessible floors, each reinforcing the abandoned, decayed aesthetic with minimal set dressing and strategic vitamin placement. Some vitamins are tucked around corners or behind walls, rewarding exploration.\r\n\r\nWhen the player reaches the bottom floor and exits the building, they're greeted by another bridge leading directly to the subway entrance. This moment offers a final view of the megastructure—looking up at the liminal bridge placements and down into the bottomless pit—before transitioning into the subway section.\r\n\r\n3. Subway Station (Final Section):  \r\nThe subway entrance descends via staircases into a main floor with three distinct areas: shops along the left wall, a ticketing area at the end, and large monitors (one broken and flickering) on the right wall. Each shop is sparse: shelves knocked over or tilted, clothing racks disoriented, and mannequins leaning or fallen. The third shop features a showcase window with a tilted mannequin and broken flickering light, reinforcing the decay theme.\r\n\r\nThe ticketing area includes two bathrooms—male and female—but the women's bathroom is blocked by traffic cones. The men's bathroom is small with a single stall. After passing through the ticketing area, the player descends another staircase to finally reach the train station platform. If the player has collected at least 10 vitamins, they can enter the train to finish the game. Upon completion, the level resets to the spawn point with all vitamins respawned, creating a looping, dream-like experience that suggests the entire journey was a caffeine-induced hallucination.\r\n\r\nNavigation is entirely walk-based with minimal jumping required, keeping the focus on atmosphere, pacing, and environmental storytelling. The vitamin placement guides the player through key areas while rewarding those who explore thoroughly. The combination of vertical traversal, bridges, confined interiors, and the final subway descent creates a cohesive 2-5 minute experience that feels deliberate, oppressive, and thematically consistent.",
    "status": "N/A"
  },
  {
    "id": "metaconstruct",
    "slug": "metaconstruct",
    "title": "METACONSTRUCT",
    "year": "N/A",
    "shortDescription": "Polished FPS game featuring procedural generation",
    "tags": [
      "UE5",
      "Producer",
      "Procedural",
      "Team"
    ],
    "platform": "PC",
    "engine": "Unreal Engine 5",
    "teamSize": "5",
    "role": "Producer",
    "language": "Blueprint",
    "duration": "14 weeks",
    "description": "METACONSTRUCT is a single‑player first‑person looter shooter set inside a decaying digital construct corrupted by an unknown anomaly. Players scavenge for resources, fight through hostile entities, and extract before the corruption overtakes them. The original pitch emphasized randomized layouts, extraction points, and enemy spawns, a liminal concrete environment, and a low‑poly, PS2‑era aesthetic. The final build scoped down from that vision due to team size and time constraints, but retained the core identity: a survival‑focused shooter with procedural elements and a digital, unstable world.\r\n\r\nThis project was selected from roughly 30 class pitches and developed over a four‑month semester in the University of Utah’s Traditional Game Development course (Michael Caldwell). I led a team of five, serving as the project’s producer and also covering level design and technical art to fill missing roles.",
    "challenges": "The biggest constraint was team size. We lacked key roles (producer, texture artist, tech/VFX, SFX, UI/UX), so I had to stretch across production, level design, and technical art while keeping the team aligned with a reduced scope. Visually, we had to build identity without a dedicated texture artist, which pushed us toward flat materials and stronger post‑processing to sell the digital decay. Technically, it was my first time implementing PCG workflows, procedural mesh generation in Unreal, and advanced post‑process effects (fog‑of‑war, stylized reveal, vertex snapping). Balancing these first‑time systems with a playable, coherent build was the core challenge.",
    "process": "I started from the approved pitch and aligned the team around a scoped‑down but cohesive feature set. As producer, I handled planning, task coordination, and milestone tracking while making sure design goals remained feasible for a small team. We chose a flat‑color material approach for speed, supplemented by post‑process effects to communicate the digital theme. We also leveraged a university SFX library rather than custom sound work to stay on schedule.\r\n\r\nOn the technical side, I built the procedural systems, fog‑of‑war pipeline, and visual effects while coordinating asset needs with our artists. Toward the end, I directed the main menu scene’s visual direction (Matrix‑inspired), managed the environment setup (lighting, camera, asset placement), and collaborated with a teammate who implemented UI functionality. The final build reflects a tight, cohesive slice of the original concept, with production lessons and technical growth as the main outcomes.",
    "custom1": "Procedural Generation\r\n\r\nI created procedural dust set dressing and hazards using Perlin noise in Unreal Engine. A Marketplace Perlin node gave me noise values, but I still had to build the mesh generation pipeline: plotting vertices across a grid, triangulating them into rectangles, and stitching the triangles into a dynamic plane mesh. I exposed frequency, magnitude, size, and UV scale to tune the visuals and used a shared randomized seed to keep all procedural systems consistent. This same approach powered a rising hazard variant to reinforce the unstable, corrupting world.\r\n\r\nI also taught myself Unreal’s PCG workflow to scatter meshes across sampled positions. Because we lacked custom building assets, I used free building meshes and synced PCG generation to the same seed managed by a level blueprint. This ensured that environmental placement, noise‑based set dressing, and hazards all aligned on a consistent procedural state.",
    "custom2": "Technical Art\r\n\r\nThe signature system was a fog‑of‑war for a first‑person shooter. I built a 1:10 scale proxy of the level off to the side and created a brush blueprint that mirrored player movement into this smaller space. A render target and dynamic material painted the brush into a mask (white = revealed, black = hidden). The post‑process then used that mask to reveal the world, blending a digital grid transition created with UV channel splits (R/G/B as axis offsets), smoothstep, and dithering. I used custom stencil filtering so the effect applied only where intended, keeping the reveal clean and readable.\r\n\r\nI also implemented a screen‑space vertex snapping post‑process inspired by PSX‑era rendering limitations. Rather than applying it globally, I limited it to enemy models to make them feel like unstable digital artifacts. Combined with the fog‑of‑war and flat‑color palette, the effect reinforced the project’s identity despite the scoped‑down asset pipeline.",
    "status": "N/A"
  },
  {
    "id": "project-quiver",
    "slug": "project-quiver",
    "title": "Project Quiver",
    "year": "N/A",
    "shortDescription": "N/A",
    "tags": [
      "UE5",
      "Procedural",
      "GAS",
      "Team"
    ],
    "platform": "PC",
    "engine": "Unreal Engine 5",
    "teamSize": "3",
    "role": "Producer, Programmer, Tech Artist",
    "language": "Blueprint, C++",
    "duration": "On-going (January 2026)",
    "description": "Project Quiver is a multiplayer, movement‑driven PvP roguelike inspired by Rounds, built in a 3D third‑person fantasy RPG style around One‑In‑The‑Quiver gameplay. Each player has three arrows and can recover them after shots; melee attacks offer a high‑risk option that also adds momentum. Movement is the core of skill expression—slides, wall slides, and wall jumps are chained together, and melee strikes provide additional directional burst. The entire system is velocity‑based, letting players maintain or build speed through advanced movement combos while fighting across a procedurally generated, tile‑based arena.\r\n\r\nThis is my second out‑of‑school project with a small team, targeting eventual release on Steam and Itch.io. We’re currently in a polished prototype phase before expanding the team for full production.",
    "challenges": "The prototype required three complex systems to work together: tile‑based procedural generation, a deep ability‑driven movement framework, and networked multiplayer synchronization. Each area had steep learning curves and hard technical constraints. I had not previously implemented Unreal’s Gameplay Ability System (GAS) or Unreal C++ workflows, and multiplayer movement introduces prediction, rollback risk, and replication accuracy issues—especially once movement goes beyond basic locomotion.\r\n\r\nOn top of that, procedural generation needed to be deterministic across server and clients, which meant syncing seeded generation while keeping the system scalable and clean enough to iterate on quickly.",
    "process": "I structured the prototype around three pillars: generation, movement abilities, and multiplayer networking. I built the tile system first to lock in repeatable arenas, then layered movement as GAS abilities so it could scale into future roguelike items and stat modifiers. Finally, I focused on replication and prediction for smooth online play, using Unreal’s replication framework and Advanced Sessions to validate Steam networking.\r\n\r\nThroughout development, I pushed toward deterministic behavior (seeded generation) and authoritative networking, while keeping the movement feel responsive and momentum‑driven on the client.",
    "custom1": "Procedural Generation\r\n\r\nThe arena is built from a deterministic tile‑grid system that supports multiple tile sizes (1x1, 2x1, 2x2) and generates layouts in three passes. First, the generator frames the outer boundary using larger tile sizes, intentionally leaving gaps for variation. Second, it fills the interior with non‑standard tiles while still preserving pockets of space. Third, it backfills all remaining gaps—including wall pieces—using 1x1 tiles. This results in a fully closed arena with mixed tile sizes that feel structured but varied.\r\n\r\nThe system is scalable by design: the map size is adjustable (minimum 3x3), and the generator uses a shared stream seed so the same seed always produces the same level. That seed is synchronized between server and clients so procedural generation is identical across the network, ensuring all players see and collide with the same tile layout every round.\r\n\r\nBecause this is a multiplayer PvP game, deterministic generation isn’t just a convenience—it’s required. If even one tile differed between host and client, movement, collision, and line‑of‑sight could desync. The seeded approach guarantees consistency while still allowing replayable variation and player‑selected map seeds for repeatable matches.",
    "custom2": "Gameplay Ability System (GAS)\r\n\r\nI implemented player movement as GAS abilities so it can scale with roguelike items and stats later (e.g., buffs, cooldowns, modifiers). This includes slide, wall slide, wall jump, and melee momentum, all of which are velocity‑driven and designed to chain together for advanced movement expression.\r\n\r\nGAS also solves a core multiplayer problem: advanced movement prediction. In Unreal, clients must feel responsive, so movement is client‑authored and server‑validated. Basic locomotion prediction is built‑in, but once movement involves custom abilities (wall slide timing, slide friction, melee impulse), prediction needs to be more precise to avoid rollback or jitter. GAS provides stronger prediction hooks and a cleaner replication model for ability‑driven actions, which lets me keep movement responsive on the client while still maintaining server authority.\r\n\r\nThis system is implemented in C++, which meant learning both the GAS C++ API and Unreal’s C++ gameplay framework for the first time. The benefit is deeper control over ability activation, prediction windows, and replication rules—critical for a fast, momentum‑based PvP game. I also used Unreal’s replication system to sync physics arrows so projectile behavior stays consistent across host and clients.",
    "status": "N/A"
  },
  {
    "id": "rogue-data",
    "slug": "rogue-data",
    "title": "Rogue Data",
    "year": "N/A",
    "shortDescription": "2D movement platformer focused on level design",
    "tags": [
      "UE5",
      "Level Design",
      "Tech Art",
      "Solo"
    ],
    "platform": "PC",
    "engine": "Unreal Engine 5",
    "teamSize": "Solo",
    "role": "Solo",
    "language": "Blueprint",
    "duration": "6 weeks",
    "description": "Rogue Data is a solo 2D side-scroller built for the second Level Design assignment (Jennifer Egan, University of Utah) over four weeks. It follows a glitched AI fragment navigating the backend of a system, and it focuses on momentum movement, an energy-driven ability set, and a color-coded hub that teaches and tests mastery while supporting the narrative.",
    "challenges": "The brief required a tutorial that explicitly teaches controls and strict content limits, so I had to balance clarity, movement feel, and visual identity within a short timeline. The assignment checklist was:\r\n\r\n- Tutorials/teaching the player how to play and use your mechanics key bindings.\r\n- Tell the player what the keybindings are, even if it's obvious.\r\n- Only use flat colors; no default Unreal textures/grids.\r\n- Include SFX and background audio (ambience/music).\r\n- Include a player mechanic beyond jumping (dash, wall jump, etc.).\r\n- Include environmental mechanics or hazards.\r\n- Player movement must fit the level metrics.\r\n- No high-poly or premade assets/textures.\r\n- Player and level reset correctly on death/fail.\r\n- Polished level with no geometry/collision issues.\r\n- Good, attractive lighting and clear end/goal.\r\n- Video and packaged build attached; package is playable.\r\n\r\nI also wanted the project to feel intentional despite my initial lack of excitement about making a 2D platformer, so I focused on movement feel, clear teaching, and a readable visual language.",
    "process": "I front-loaded time on visuals and mechanics so I could focus on level design later. The player has walljump, dash, and cursor-drag abilities; dash and drag consume a shared energy bar that only recharges on the ground. Dash spends all remaining energy to determine distance, while drag drains at a steady rate until the object is released or energy is empty. I iterated on movement feel through playtests, and I used on-screen keybinding prompts to ensure the tutorial taught controls clearly.",
    "custom1": "Level Design\r\n\r\nThe tutorial uses bright white with CMYK accents to create a diagnostic feel, then a locked-room sequence with a broken teleport timer shifts the game into a dark RGB/black “glitched” world. A buffer climb area of loose, falling-apart platforms introduces higher difficulty before the main hub. The hub centers on three colored pads (blue puzzle, green accuracy, red speed) and key collection; the puzzle section was scoped out, so its key sits nearby to teach the hub mechanic. The accuracy route uses emissive arrow boosters that push the player off the intended path, forcing precision; the key must then be dragged back to the hub. The speed route uses red dissolving platforms that respawn after a delay, limiting energy recharge and forcing smart dash timing with rest platforms between sections. The ending resolves with a bright light and gravity reversal that lifts the player upward.",
    "custom2": "Technical Art\r\n\r\nThe player character is a Niagara voxel build made by sampling the Quinn skeletal mesh and placing evenly spaced emissive cubes. The energy bar shifts from green to red, and the voxel body fades from the bottom up as energy drains, letting players read energy without staring at the UI. I leaned on flat colors, emissive accents, and audio to reinforce the diagnostic-to-glitch transition, and playtests confirmed the emissive language improved readability.",
    "status": "N/A"
  },
  {
    "id": "tiny-sheriff",
    "slug": "tiny-sheriff",
    "title": "Tiny Sheriff",
    "year": "N/A",
    "shortDescription": "2D movement platformer where weapons become traversal tools, built in Unity.",
    "tags": [
      "Unity",
      "C#",
      "Tech Art",
      "Team"
    ],
    "platform": "PC",
    "engine": "Unity",
    "teamSize": "25",
    "role": "Programmer, VFX/Tech Artist",
    "language": "C#",
    "duration": "9 months (2 semesters)",
    "description": "Tiny Sheriff is a 2D movement platformer where weapons are traversal tools. Each shot propels the player through the air, enabling dash, double‑jump, and wall‑bounce movement while keeping combat fast, chaotic, and momentum‑driven. Enemies and hazards (including cacti) force precise control—mistimed shots can launch the player into danger, so movement mastery is the core skill.\r\n\r\nThe project was developed as part of the University of Utah Division of Games Capstone, a two‑semester, industry‑modeled course where teams build a full game from the ground up. I joined the Tiny Sheriff team after the project was selected into the final set of capstone games and after an early demo had already established three weapons (double‑barrel shotgun, harpoon, and SMG prototype).",
    "challenges": "I joined an existing prototype that relied heavily on Unity’s default functions and hard‑coded logic, which created timing bugs (weapon swapping, execution order) and made progression systems harder to manage. Movement also mixed Translate and velocity‑based motion, which broke momentum consistency—especially for a game where knock‑back movement is the core mechanic.\r\n\r\nIn Capstone 2, I transitioned from engineering to technical art, which meant building VFX and shader work in Unity for the first time while still supporting gameplay implementation. The challenge was shipping production‑ready visuals that level designers could use without specialized setup.",
    "process": "During Capstone 1, I focused on stabilizing systems and re‑architecting player movement. I converted the codebase from scattered, hard‑coded actions to a unified event‑based approach so gameplay systems could trigger in a controlled, predictable order. This also unlocked better ammo handling and progression logic (weapon unlocks vs. full access in the prototype).\r\n\r\nIn Capstone 2, after planning and design meetings for the next level set, I pitched the wind mechanic and helped implement it both technically and visually. I then shifted toward technical art to raise visual quality, building reusable effects that were easy for designers to drop into levels.",
    "custom1": "Engineering\r\n\r\nI replaced the prototype’s mixed movement approach with a velocity‑only system. This preserved knock‑back momentum, aligned better with weapon propulsion, and enabled the wind mechanic to work consistently.\r\n\r\nI also reworked the project into an event‑driven architecture. A shared event handler and manager tracked event order and execution timing, which fixed critical issues like weapon swapping and action sequencing. This structure made it easier to manage ammo logic and lock/unlock weapons as part of game progression.",
    "custom2": "Technical Art\r\n\r\nI built a wind particle system designed for designers. The effect exposed adjustable range controls to match the gameplay wind trigger zones, making it easy to tune visuals to mechanics. I also collaborated on the implementation side by exposing velocity parameters that designers could manipulate.\r\n\r\nTo push atmosphere, I created a heat‑wave background effect using Unity’s Shader Graph. By combining time‑based sine waves across multiple channels, I achieved a shimmering haze that reads as hot air distortion. Like the wind VFX, the heat‑wave was packaged as a prefab so designers could place and scale it without technical setup.",
    "status": "N/A"
  }
]
